<?php
/*******************************************************************************
 * Ringside Networks, Harnessing the power of social networks.
 *
 * Copyright 2008 Ringside Networks, Inc., and individual contributors as indicated
 * by the @authors tag or express copyright attribution
 * statements applied by the authors.  All third-party contributions are
 * distributed under license by Ringside Networks, Inc.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 ******************************************************************************/

require_once( 'ringside/social/api/RingsideSocialApiTrust.php' );
require_once( 'ringside/social/RingsideSocialUtils.php' );
require_once( 'ringside/social/config/RingsideSocialConfig.php' );
require_once( 'ringside/api/clients/RingsideApiClientsRest.php' );
require_once( 'ringside/social/session/RingsideSocialSession.php' );
require_once( 'ringside/social/api/RingsideSocialApiRender.php');
require_once( 'ringside/social/client/RingsideSocialClientLocal.php');
require_once( 'ringside/web/RingsideWebUtils.php');
require_once( 'ringside/web/config/RingsideWebConfig.php');

/**
 * @optional method
 * 		convert_session
 * 		widget
 * 		verify
 * 		newprofile
 * 		bindmap
 * 		finalizemap
 *
 * @optional fb_sig_session_key The actual session key from logging into a Facebook compliant server.
 * @optional fb_sig_api_key The api key registered on the Facebook compliant server you are logged into.
 * @optional trust_key The trust authority used to log the user in.  Defaults to the local server.
 *
 */
class RingsideSocialServerTrust
{	
	private $debugMode=false;
	private function debug($text){
		if($this->debugMode){
			error_log("RingsideSocialServerTrust:".$text);
		}
	}
	private function debugVar($var){
		if($this->debugMode){
			error_log("RingsideSocialServerTrust:".var_export($var,true));
		}		
	}
	
	/**
     * This is a proxy method.  It creates a trust relationship with the trust authority if auth_token is passed in.
     * Redirects to the application callback url, or social_callback
     * Requires app_name param
     *
     * @param Array $params
     */
    public function execute(&$params) {

        if(array_key_exists('method', $params)){

            $method = $params['method'];
            
            if($method == 'convert_session' ) {
				self::convert_session($params);
				return;
            } else if ( $method == 'widget' ) {
				self::trust_widget($params);
				return;
            } else if( $method=='verify' ){
            	self::verify_session($params);
            	return;
            } else if ( $method == 'newprofile' ) {
                self::createNewProfile($params);
                return;
            } else if ( $method == 'bindmap' ) {
            	self::bindmap($params);
            	return;
            } else if ( $method == 'finalizemap' ) {
				self::finalizemap($params);
				return;
            } else {
            	self::proxy_app_request( $params );
            }
        }
     }

    /**
     * Creates a REST client for the session.
     *
     * @param string $social_session_key the session key generated by the social renderer when the application was rendered.
     * @return RingsideApiClientsRest the REST client
     */
    private static function createRestClient(&$social_session_key) {
        if (empty($social_session_key)) { unset($social_session_key); }
        //		error_log("Using session key $social_session_key");
        $network_session = new RingsideSocialSession(isset($social_session_key)?$social_session_key:null);
        if ( $network_session->getUserId() == null ) {
            // This is the Ringside user
            $network_session->setUserId(1);
        }
        $api_session_key = RingsideSocialUtils::getApiSessionKey(RingsideSocialConfig::$apiKey, RingsideSocialConfig::$secretKey, $network_session);
        //		error_log("API session key is $api_session_key");
        $social_session_key = $network_session->getSessionKey();
        return new RingsideApiClientsRest(RingsideSocialConfig::$apiKey, RingsideSocialConfig::$secretKey, $api_session_key, RingsideApiClientsConfig::$serverUrl, RingsideApiClientsConfig::$webUrl, RingsideApiClientsConfig::$socialUrl);
    }

    private static function getBaseUrl() {
        $request_url = 'http://'.$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];
        $query_frag = strpos($request_url, '?');
        if ( $query_frag !== false ) {
            //			error_log("Trimming $request_url to ".substr($request_url, 0, $query_frag));
            $request_url = substr($request_url, 0, $query_frag);
        }
        return $request_url;
    }

    private static function buildProxyUrl($callback_url, $url) {
        $request_url = self::getBaseUrl();
        // We will need to translate to the remote network's registered location
        $real_location = preg_replace(',^'.$callback_url.',', $request_url, $url);
        // Also need to replace locations in 'next' url params
        $real_location = preg_replace(',next='.urlencode($callback_url).',', 'next='.urlencode($request_url), $real_location);
        error_log("Proxy URL: '$real_location' (for '$url' with callback '$callback_url')");
        return $real_location;
    }

    private static function buildCanvasUrl( $url, $props, $trust_info) {
        $canvas_url = $props['canvas_url'];
        $path_within_canvas = '/'.preg_replace(',^'.$props['callback_url'].',','', $url);
        $path_within_canvas = preg_replace(',^'.self::getBaseUrl().',','', $path_within_canvas);
        $proxy_canvas_url = self::safe_append_url(self::safe_append_url(self::safe_append_url($trust_info['trust_canvas_url'],'/'), $canvas_url ), $path_within_canvas);
        error_log("Canvas URL: is '$proxy_canvas_url'");
        return $proxy_canvas_url;
    }

    private static function safe_append_url($baseurl, $moreurl) {
        if ( $baseurl && $baseurl[strlen($baseurl)-1] == '/' && $moreurl && $moreurl[0] == '/' ) {
            return $baseurl . substr($moreurl, 1);
        } else if ( $baseurl && $baseurl[strlen($baseurl)-1] != '/' && $moreurl && $moreurl[0] != '/' ) {
            return $baseurl . '/' .$moreurl;
        } else {
            return $baseurl . $moreurl;
        }
    }

    /**
     * Post a mapping request, either mapping or profile creation,
     * this url is where you should go.  This method will set the redirect as well.
     *
     * @param string $next portion of url to append
     * @param boolean $isCanvas is the page a canvas page we are directing to
     * @param boolean $isIframe is the page an iframe
     * @param boolean $usePostMapUrl should we just go to the post map url
     * @param array $hostNetworkInfo what is the HOST network and its info ( the network we started from)
     * @param array $deployedAppProperties properties of the application deployed
     */
    private static function postMapRedirect( $next, $isCanvas, $isIframe, $usePostMapUrl, $hostNetworkInfo, $deployedAppProperties ) {

        // Find where to go after this request.
        if( $usePostMapUrl === true ) {

            // go to the SNIDS post map url
            $postMapUrl = $hostNetworkInfo['trust_postmap_url'];
            if ( strpos( $next, $postMapUrl ) !== 0 ) {
                $postMapUrl .= $next ;
            }
            $next = $postMapUrl;

        } else if ( $isCanvas === true || $isIframe === true ) {
            $next = self::buildCanvasUrl( $next, $deployedAppProperties, $hostNetworkInfo);
            //				     echo "Finished. Would redirect to canvas for $next: ".self::buildCanvasUrl($snid, $props['canvas_url'],$next, $props);
        }
         
        error_log( "REDIR (canvas:$isCanvas) (iframe:$isIframe) (pmapurl:$usePostMapUrl) . $next ");
        // Need to redirect somewhere
        // This is the finalize of the map process.
        // The map process could have occured in a popup as well.
        // Where and how we redirect needs some controls.
        	
        if ( $isCanvas === true ) {
            //			         error_log("Redirecting top-level to canvas url $next");
            echo "<script>top.location.href='$next';</script>";
            return;
        } else {
            RingsideWebUtils::redirect($next);
        }

    }

    /**
     * Looks up and returns (both as return parameters and an array) the api key and secret
     * for the requested network for a specific application.  If $default_api_key and $default_secret
     * they will be unmodified if there is no registered equivelent key on the requested network and
     * can be used as default values.
     *
     * @param string $network_id
     * @param string $network_app_props
     * @param string $default_api_key [RET]
     * @param string $default_secret [RET]
     * @return array an array containing {'api_key','secret'} for the requested network
     */
    
     private static function getApiKeyAndSecretForNetwork($network_id, $network_app_props, &$default_api_key, &$default_secret) {
        error_log("Getting keys for network $network_id");
        foreach ( $network_app_props as $network_app_prop ) {
            error_log("Checking '{$network_app_prop['network_id']}' against '$network_id'");
            if ( $network_app_prop['network_id'] == $network_id && ! empty($network_app_prop['api_key']) && ! empty($network_app_prop['secret']) ) {
                $default_api_key = $network_app_prop['api_key'];
                $default_secret = $network_app_prop['secret'];
            }
        }
        
        return array($default_api_key, $default_secret);
    }
    
    
    /**
     * Create a new profile for a mapped used on the local server.
     *
     * @param unknown_type $params
     */
    private static function createNewProfile($params) {
        // get out the parameters
        $next = isset( $params['next'] ) ? $params['next'] : null;
        $nid =  isset( $params['nid'] ) ? $params['nid'] : null;
        $sid =  isset( $params['sid'] ) ? $params['sid'] : null;
        $snid =  isset( $params['snid'] ) ? $params['snid'] : null;
        $api_key =  isset( $params['api_key'] ) ? $params['api_key'] : null;
        $sig =  isset( $params['sig'] ) ? $params['sig'] : null;
        $session_key =  isset( $params['session_key'] ) ? $params['session_key'] : null;
        $canvas = isset( $params['canvas'] ) ? true : false;
        $network = isset( $params['network'] ) ? true : false;
        $iframe = isset( $params['fb_sig_in_iframe'] ) ? ($params['fb_sig_in_iframe']=='1'?true:false) : false;

        try {
            // create the principal requested
            $ringside_rest = RingsideSocialUtils::getAdminClient( $snid );

            // OK we mapped redirect user.
            $deployed_app = $ringside_rest->admin_getAppProperties(array('application_id', 'api_key', 'canvas_url', 'callback_url'), null, null, $api_key, $snid);
            $host_network = $ringside_rest->admin_getTrustInfo( $snid );
            $pid = $ringside_rest->admin_createPrincipal($sid, $snid, $deployed_app['application_id']);
            self::postMapRedirect( $next, $canvas, $iframe, $network, $host_network[0], $deployed_app );

        } catch ( Exception $e ) {
            error_log($e->getMessage());
            error_log($e->getTraceAsString());
            echo "Exception when creating new profile";
            throw $e;
        }

        return;
    }
    
	/**
	 * Process a conversion step where there is an incoming
     * fb_sig_session_key and fb_sig_api_key and it needs to be converted to a
     * DEPLOYED network session.
	 *
	 * @param array $params
	 */
	public static function convert_session(array &$params){
		// TODO SNID extensible.
		if(array_key_exists('social_session_key', $params)) {
			echo $params['social_session_key'];
			return;
		} else if (array_key_exists('fb_sig_session_key', $params) && array_key_exists('fb_sig_api_key', $params)) {  
			$skey = isset($_REQUEST['fb_sig_session_key'])? $_REQUEST['fb_sig_session_key']: '';
			$apiKey = isset($_REQUEST['fb_sig_api_key'])? $_REQUEST['fb_sig_api_key']: '';
			$trustKey = isset($_REQUEST['trust_key'])? $_REQUEST['trust_key']: '';	
			$trust = new RingsideSocialApiTrust($_REQUEST);
			$network_session = $trust->getNetworkSession($apiKey, null, $skey, $trustKey);
			echo $network_session->getSessionKey();
			return;
	    }
	}
	
	/**
	 * Converts and auth token into an api session
	 *
	 * @param Array $params
	 * 
	 */
	public static function trust_widget(&$params){
		try{
			$session_key = $params['social_session_key'];
		    $callback = null;
		    if(array_key_exists('auth_token', $params)){
		        $auth_token = $params['auth_token'];
		        if(isset($auth_token)){
		            $trust = new RingsideSocialApiTrust($params);
		            $callback = $trust->authorize();
		        }
		    } else if(array_key_exists('session', $params)) {
  					  		$this->debug("A facebook session object has been received".$params['session'].". It will be adopted.");
							$trust = new RingsideSocialApiTrust($params);
							$callback = $trust->authorize();
				            $this->debug("callback is now $callback");
							//$session_key = $params['social_session_key'];

			} else if(array_key_exists('social_session_key', $params)) {
		        $session_key = $params['social_session_key'];
		        if(isset($session_key))  {
		            $network_session = new RingsideSocialSession($session_key);
		            $callback = $network_session->getCallbackUrl();
		        }
		
		    }else if(array_key_exists('api_key', $params) || array_key_exists('canvas_url', $params)) {
		        $trust = new RingsideSocialApiTrust($params);
		        $result = $trust->getAppProperties();
		
		        if($result) {
		            $callback = isset( $result['callback_url'] )? $result['callback_url'] : '';
		        }
		
		    } else if(array_key_exists('social_callback', $params)) {
		        $callback = $params['social_callback'];
		    }
		
		    if(isset($callback)) {
		        $decorated_callback=$callback;
		        if(defined($session_key)){
		            if(strrpos($decorated_callback,'?')==0){
		                $decorated_callback=$decorated_callback."?session_key=$session_key";
		            } else {
		                $decorated_callback=$decorated_callback."&session_key=$session_key";
		            }
		        }
		        header( "Cache-control: private");
		        header( "Location: $decorated_callback" );
		        exit();
		    }
		    return;
		} catch(Exception $exception) {
		    error_log("Exception in Widget Trust: ".$exception->getMessage()."\n".$exception->getTraceAsString());
		    echo "<ERROR>".$exception->getMessage()."</ERROR>";
		    return;
		}
	}

	public static function verify_session(&$params){
		$session_key = $params['social_session_key'];
		$network_session = new RingsideSocialSession($session_key);
		if($network_session) //precondition
		{
			echo "authneticateResponse(".json_encode(array('authenticated'=>$network_session->isLoggedIn())).");";
		} else {
			echo "authneticateResponse(".json_encode(array('authenticated'=>false)).");";
		}
		
		return;
	}
	
	/**
	 * Start the process of binding a mapping request.
	 * This step will ask the NETWORK to be mapped to authenticate the user.
	 * To that network we need a NEXT url to go to after login.
	 * 
	 * @param array $params
	 */
	private static function bindmap(&$params){
		error_log("Binding map with parameters: ".var_export($params, true));

	 	// We expect the following parameters coming in.
		$next = isset( $params['next'] ) ? $params['next'] : null;
		$nid =  isset( $params['nid'] ) ? $params['nid'] : null;
		$sid =  isset( $params['sid'] ) ? $params['sid'] : null;
		$snid =  isset( $params['snid'] ) ? $params['snid'] : null;
		$api_key =  isset( $params['api_key'] ) ? $params['api_key'] : null;
		$sig =  isset( $params['sig'] ) ? $params['sig'] : null;
		$session_key =  isset( $params['session_key'] ) ? $params['session_key'] : null;
		$canvas = isset( $params['canvas'] ) ? true : false;
		$network = isset( $params['network'] ) ? true : false;

		if ( $snid == $nid ) {
			// The user selected this network from the drop-down list; this means they want a new profile
			self::createNewProfile($params);
			$next = isset( $params['next'] ) ? $params['next'] : null;
			$nid =  isset( $params['nid'] ) ? $params['nid'] : null;
			$sid =  isset( $params['sid'] ) ? $params['sid'] : null;
			$snid =  isset( $params['snid'] ) ? $params['snid'] : null;
			$api_key =  isset( $params['api_key'] ) ? $params['api_key'] : null;
			$sig =  isset( $params['sig'] ) ? $params['sig'] : null;
			$canvas = isset( $params['canvas'] ) ? true : false;
			$network = isset( $params['network'] ) ? true : false;
			$iframe = isset( $params['fb_sig_in_iframe'] ) ? ($params['fb_sig_in_iframe']=='1'?true:false) : false;
			$auth_token = isset( $params['auth_token'] ) ? $params['auth_token'] : null;
			
			
			// FALLTHROUGH (WHAT SHOULD OCCUR HERE????)
			
		} else {
			try {

				$ringside_rest = RingsideSocialUtils::getAdminClient( $snid );
				$app_properties = $ringside_rest->admin_getAppProperties(array('api_key', 'secret_key', 'canvas_url'), null, null, $api_key, $snid);
				if ( ! isset($app_properties['secret_key'] ) ) {
					echo "A mapping request was made for an unknown application, identified as $api_key";
					echo "Press your browser back button to return the previous page.";
					return;
				}

				$nid_infos = $ringside_rest->admin_getTrustInfo(array($nid));
				if ( isset($nid_infos[0]) && isset($nid_infos[0]['trust_login_url'] ) ) {
					// We are going to need a URL to redirect in the other networks login.
					$post_login = 'http://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'] . '/';
					$post_login .= $nid . '/' . $app_properties['canvas_url'] ;
					$post_login .= '?method=finalizemap';
					$post_login .= '&api_key=' . $api_key;
					$post_login .= '&sid=' . $sid;
					$post_login .= '&snid=' . $snid;
					$post_login .= '&nid='.$nid;
					$post_login .= '&next=' . urlencode($next);
					$post_login .=  ($canvas===true)?'&canvas':'';
					$post_login .=  ($network===true)?'&network':'';

					$network_app_props = $ringside_rest->admin_getAppKeys(null, null, $api_key, $snid);
					$network_api_key = $api_key;
					$network_secret = '';
					self::getApiKeyAndSecretForNetwork($nid, $network_app_props, $network_api_key, $network_secret);

					// TODO building this url should be done via extension.
					$loginUrl = $nid_infos[0]['trust_login_url'];
					$loginUrl .= '?v=1.0';
					$loginUrl .= '&skipcookie';
					$loginUrl .= '&trust';
					$loginUrl .= '&popup';
					$loginUrl .= '&api_key=' . $network_api_key;
					$loginUrl .= '&session_key=' . $session_key;
					$loginUrl .= '&next=' . urlencode($post_login);
					//			      error_log("Redirecting to: ".$loginUrl);

					RingsideWebUtils::redirect( $loginUrl );
				} else {
					error_log("Warning: No login URL defined for trust key $nid; using Facebook login URL");
					echo "A mapping request was made to an unknown network, identified as $nid";
					echo "Press your browser back button to return the previous page.";
					//			      RingsideWebUtils::redirect("http://www.facebook.com/login.php?v=1.0&skipcookie&api_key=$api_key&session_key=$session_key&next=".urlencode($fb_next));
				}
			} catch ( Exception $e ) {
				error_log("Error: When binding the mapping: ".$e->getMessage());
				error_log($e->getTraceAsString());
				echo "Exception when binding the user mapping, " . $e->getMessage();
			}
			 
			return;
		}

	}
	
	/**
	 * Finalize the mapping process, this ties a user on a network to a Principal id for that user.
	 * This is typically the endpoint of a given login request on a third party social network.
	 * The method bindmap must have been called first since that setups the request to a login request on a
	 * foreign social network.
	 *
	 * @param array $params
	 */
	private static function finalizemap(&$params){
                error_log("Finalizing map with parameters: ".var_export($params, true));
                $next = isset( $params['next'] ) ? $params['next'] : null;
                $nid =  isset( $params['nid'] ) ? $params['nid'] : null;
                $sid =  isset( $params['sid'] ) ? $params['sid'] : null;
                $snid =  isset( $params['snid'] ) ? $params['snid'] : null;
                $api_key =  isset( $params['api_key'] ) ? $params['api_key'] : null;
                $sig =  isset( $params['sig'] ) ? $params['sig'] : null;
                $canvas = isset( $params['canvas'] ) ? true : false;
                $network = isset( $params['network'] ) ? true : false;
                $iframe = isset( $params['fb_sig_in_iframe'] ) ? ($params['fb_sig_in_iframe']=='1'?true:false) : false;
                $auth_token = isset( $params['auth_token'] ) ? $params['auth_token'] : null;

                try {
                    // Get some information about the calling application and registered networks.
                    error_log("Finalizing map from $snid to $nid");
                    $ringside_rest = RingsideSocialUtils::getAdminClient( $snid );
                    $deployed_app = $ringside_rest->admin_getAppProperties(array('application_id', 'api_key', 'secret_key', 'canvas_url', 'callback_url'), null, null, $api_key, $snid);
                    $trust_info = $ringside_rest->admin_getTrustInfo(array($snid, $nid));
                    $network_app_props = $ringside_rest->admin_getAppKeys(null, null, $deployed_app['api_key'], $snid);
                    $host_network = $trust_info[0];
                    $auth_network = $trust_info[1];
                    $network_api_key = $deployed_app['api_key'];
                    $network_secret = $deployed_app['secret_key'];
                    self::getApiKeyAndSecretForNetwork($auth_network['trust_key'], $network_app_props, $network_api_key, $network_secret);
                    
                    // validate against social network this auth token and get registered user
                    error_log("For auth network {$auth_network['trust_key']}, API key is $network_api_key and secret is $network_secret");
                    $auth_network_rest = new RingsideApiClientsRest(  $network_api_key, $network_secret );
                    $auth_network_rest->setDefaultServer($auth_network['trust_auth_url'], null);
                    $auth_user_info = $auth_network_rest->auth_getSession($auth_token);
                    $auth_user = $auth_user_info['uid'];

                    // if a profile was not created relative to that network, you need to 'create' profile first.
                    $pid = null;
                    if ( $auth_user != null ) {
                        // We have successfully authenticated the user against the remote network...
                        error_log(var_export($deployed_app, true));
                        $ringside_rest->admin_mapUser($auth_user, $nid, $sid, $snid, $deployed_app['application_id']);
                    }
                     
                    // Map the USER

                    // OK we mapped redirect user.
                    self::postMapRedirect( $next, $canvas, $iframe, $network, $host_network, $deployed_app );
                     
                } catch ( Exception $e ) {
                    error_log("Error: When finalizing the mapping: ".$e->getMessage());
                    error_log($e->getTraceAsString());
                    echo "Exception when finalizing the UID mapping, " . $e->getMessage();
                }

                return;		
	}


	/**
	 * Re-routes an api request to another network. If trust.php is used as a rest server URL
	 * and a path info is provided such that the request looks like the one below:
	 * 
	 *        http://localhost/trust.php/facebook/footprints/restserver.php 
	 *            or
	 *        http://localhost/trust.php/{network}/{canvas url}/{restserver path}
	 *  
	 * Attempts to remap and resign the api call using the app's secret on the new network
	 * and then to change the uid to the equivelent uid on the forgin network.
	 * 
	 * The api call is then re-signed and issued and the response is returned.
	 * 
	 * @param unknown_type $params
	 */
	private static function proxy_app_request(&$params){
		
		$matches = array();
		// All these special cases are to ensure we aren't adding an additional "/" character to the URL.
		preg_match(',^/([^/]*)/([^/]*)(/?.*)$,', $_SERVER['PATH_INFO'], $matches);
		$network_key = $matches[1];
		$canvas_url = $matches[2];
		$rest = $matches[3];
		if ( $rest == '' ) {
			$rest = '/';
		}
		if ( $network_key != RingsideSocialConfig::$apiKey ) {
			$skey = isset($_REQUEST['fb_sig_session_key'])? $_REQUEST['fb_sig_session_key']: '';
			$apiKey = isset($_REQUEST['fb_sig_api_key'])? $_REQUEST['fb_sig_api_key']: '';
			$ringside_rest = self::createRestClient($params['fb_sig_session_key']);
			$admin_rest = RingsideSocialUtils::getAdminClient();
			$props = $admin_rest->admin_getAppProperties( "application_id,application_name,api_key,secret_key,callback_url" , null, $canvas_url, NULL);
			$network_app_props = $admin_rest->admin_getAppKeys(null, null, $props['api_key']);
			$network_api_key = $props['api_key'];
			$network_secret = $props['secret_key'];
			self::getApiKeyAndSecretForNetwork($network_key, $network_app_props, $network_api_key, $network_secret);

			$network_session = new RingsideSocialSession($params['fb_sig_session_key']);
			$idmaps = $ringside_rest->users_mapToPrincipal(array($params['fb_sig_user']), $network_key, $props['application_id']);
				
			// Create openFB request. These are just overrides for the original request.
			$has_fb_sig = isset($params['fb_sig']);
				
			$cbReq = array();
			// We can't append fb_sig unless Facebook has already passed fb_sig; this would prevent the app's client from creating a session during login
			if ( $has_fb_sig ) {
				if ( isset($params['fb_sig_nuser']) ) {
					// Since we're proxying a request, do NOT forward the user mapping!
					unset($params['fb_sig_nuser']);
				}
				$cbReq['fb_sig_flavor'] = 'canvas';
				//				      $cbReq['fb_sig_in_iframe'] = 0;
				$cbReq['fb_sig_nid'] = $network_key;
				// The social session key needs to be for _this_ social session!
				$cbReq['fb_sig_soc_session_key'] = $network_session->getSessionKey();
				if ( !empty($idmaps) && isset($idmaps[0]) && $idmaps[0] !== null ) {
					$cbReq['fb_sig_nuser'] = $idmaps[0]['pid'];
				}
			}
				
			// error_log("cbReq social session key is {$cbReq['fb_sig_soc_session_key']}; params is $fb_sig_soc_session_key");
			// TODO: Set up social session key for trust-based proxy
			// $cbReq['fb_sig_soc_session_key'] = ;
			$req_params = array_merge( $params, $cbReq );
				
			error_log("Invoking $canvas_url with params: ".var_export($req_params, true));

			// Now, we need to re-sign the parameters, since we've added the "nid" and "nuser" fb_sig params
			if ( $has_fb_sig ) {
				unset($req_params['fb_sig']);
				$sig = RingsideSocialUtils::makeSig( $req_params, $network_secret, 'fb_sig' );
				$req_params['fb_sig'] = $sig;
			}

			//					error_log("Logged in user is principal ".$pids[0]);
			//					error_log("Proxying to app callback URL ".$props['callback_url']);
			$headers = array();
			$callback_url = self::safe_append_url($props['callback_url'], $rest);
			$result = RingsideSocialUtils::get_request($callback_url , $req_params, $headers );
			//					error_log("Result: $result");
			if ( isset($headers['location']) ) {
				$proxy_redir_url = self::buildProxyUrl($props['callback_url'], $headers['location']);
				error_log("Proxying for redirect to $proxy_redir_url");
				// Build the remote network's callback_url
				// We'll redirect _within_ the frame (the commented-out script will redirect the _top_ of the frame
				if ( isset($params['fb_sig_in_iframe']) && 0 != $params['fb_sig_in_iframe'] ) {
					//							RingsideWebUtils::redirect($headers['location']);
					$apps_url = RingsideApiClientsConfig::$webUrl.'/canvas.php';
					if ( $nid == 'facebook' ) {
						$apps_url = 'http://apps.facebook.com/';
					}
					//							$real_location = self::buildProxyUrl($props['callback_url'], $headers['location']);
					//							echo "<script>top.location.href='".$real_location."';</script>";
					RingsideWebUtils::redirect($proxy_redir_url);
				} else {
					//							$real_location = self::buildProxyUrl($props['callback_url'], $headers['location']);
					if ( isset($params['fb_sig_in_canvas']) && 0 != $params['fb_sig_in_canvas'] ) {
						echo "<fb:redirect url='$proxy_redir_url'/>";
					} else {
						RingsideWebUtils::redirect($proxy_redir_url);
					}
				}

				return;
			}
			echo $result;
			return;
		}
		// Map network user to principal
		// Rewrite fb_sig
		// Proxy to callback_url
		echo '<ERROR>Unknown Callback_Url!</ERROR>';

	}
}
?>
